Article 1001 of comp.sources.unix:
Path: s.cc.purdue.edu!h.cc.purdue.edu!j.cc.purdue.edu!pur-ee!iuvax!inuxc!ihnp4!ptsfa!pyramid!decwrl!sun!pitstop!sundc!seismo!uunet!rsalz
From: rsalz@uunet.UU.NET (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v12i018:  OPS5 in Common Lisp, Part03/05
Message-ID: <2261@uunet.UU.NET>
Date: 14 Oct 87 02:21:25 GMT
Organization: UUNET Communications Services, Arlington, VA
Lines: 854
Approved: rs@uunet.UU.NET

Submitted-by: eric@dlcdev.UUCP (eric van tassell)
Posting-number: Volume 12, Issue 18
Archive-name: ops5/part03

[  Note that this package is not a shar file.  Consider this an experiment,
   similar to the patch file I recently published.  Comments?  -r$  ]

; the following two functions encode indices so that gelm can
; decode them as fast as possible

(defun encode-pair (a b) (+ (* 10000. (1- a)) (1- b))) 

(defun encode-singleton (a) (1- a)) 

(defun promote-var (dope)
  (prog (vname vpred vpos new)
        (setq vname (car dope))
        (setq vpred (cadr dope))
        (setq vpos (caddr dope))
        (or (eq 'eq vpred)
            (%error '|illegal predicate for first occurrence|
                   (list vname vpred)))
        (setq new (list vname 0. vpos))
        (setq *vars* (cons new *vars*)))) 

(defun fudge nil
  (mapc (function fudge*) *vars*)
  (mapc (function fudge*) *ce-vars*)) 

(defun fudge* (z)
  (prog (a) (setq a (cdr z)) (rplaca a (1+ (car a))))) 

(defun build-beta (type tests)
  (prog (rpred lpred lnode lef)
        (link-new-node (list '&mem nil nil (protomem)))
        (setq rpred *last-node*)
        (cond ((eq type '&and)
               (setq lnode (list '&mem nil nil (protomem))))
              (t (setq lnode (list '&two nil nil))))
        (setq lpred (link-to-branch lnode))
        (cond ((eq type '&and) (setq lef lpred))
              (t (setq lef (protomem))))
        (link-new-beta-node (list type nil lef rpred tests)))) 

(defun protomem nil (list nil)) 

(defun memory-part (mem-node) (car (cadddr mem-node))) 

(defun encode-dope nil
  (prog (r all z k)
        (setq r nil)
        (setq all *vars*)
   la   (and (atom all) (return r))
        (setq z (car all))
        (setq all (cdr all))
        (setq k (encode-pair (cadr z) (caddr z)))
        (setq r (cons (car z) (cons k r)))
        (go la))) 

(defun encode-ce-dope nil
  (prog (r all z k)
        (setq r nil)
        (setq all *ce-vars*)
   la   (and (atom all) (return r))
        (setq z (car all))
        (setq all (cdr all))
        (setq k (cadr z))
        (setq r (cons (car z) (cons k r)))
        (go la))) 



;;; Linking the nodes

(defun link-new-node (r)
  (cond ((not (member (car r) '(&p &mem &two &and &not)))
	 (setq *feature-count* (1+ *feature-count*))))
  (setq *virtual-cnt* (1+ *virtual-cnt*))
  (setq *last-node* (link-left *last-node* r))) 

(defun link-to-branch (r)
  (setq *virtual-cnt* (1+ *virtual-cnt*))
  (setq *last-branch* (link-left *last-branch* r))) 

(defun link-new-beta-node (r)
  (setq *virtual-cnt* (1+ *virtual-cnt*))
  (setq *last-node* (link-both *last-branch* *last-node* r))
  (setq *last-branch* *last-node*)) 

(defun link-left (pred succ)
  (prog (a r)
        (setq a (left-outs pred))
        (setq r (find-equiv-node succ a))
        (and r (return r))
        (setq *real-cnt* (1+ *real-cnt*))
        (attach-left pred succ)
        (return succ))) 

(defun link-both (left right succ)
  (prog (a r)
        (setq a (interq (left-outs left) (right-outs right)))
        (setq r (find-equiv-beta-node succ a))
        (and r (return r))
        (setq *real-cnt* (1+ *real-cnt*))
        (attach-left left succ)
        (attach-right right succ)
        (return succ))) 

(defun attach-right (old new)
  (rplaca (cddr old) (cons new (caddr old)))) 

(defun attach-left (old new)
  (rplaca (cdr old) (cons new (cadr old)))) 

(defun right-outs (node) (caddr node)) 

(defun left-outs (node) (cadr node)) 

(defun find-equiv-node (node list)
  (prog (a)
        (setq a list)
   l1   (cond ((atom a) (return nil))
              ((equiv node (car a)) (return (car a))))
        (setq a (cdr a))
        (go l1))) 

(defun find-equiv-beta-node (node list)
  (prog (a)
        (setq a list)
   l1   (cond ((atom a) (return nil))
              ((beta-equiv node (car a)) (return (car a))))
        (setq a (cdr a))
        (go l1))) 

; do not look at the predecessor fields of beta nodes; they have to be
; identical because of the way the candidate nodes were found

(defun equiv (a b)
  (and (eq (car a) (car b))
       (or (eq (car a) '&mem)
           (eq (car a) '&two)
           (equal (caddr a) (caddr b)))
       (equal (cdddr a) (cdddr b)))) 

(defun beta-equiv (a b)
  (and (eq (car a) (car b))
       (equal (cddddr a) (cddddr b))
       (or (eq (car a) '&and) (equal (caddr a) (caddr b))))) 

; the equivalence tests are set up to consider the contents of
; node memories, so they are ready for the build action

;;; Network interpreter

(defun match (flag wme)
  (sendto flag (list wme) 'left (list *first-node*)))

; note that eval-nodelist is not set up to handle building
; productions.  would have to add something like ops4's build-flag

(defun eval-nodelist (nl)
  (prog nil
   top  (and (not nl) (return nil))
        (setq *sendtocall* nil)
	(setq *last-node* (car nl))
        (apply (caar nl) (cdar nl))
        (setq nl (cdr nl))
        (go top))) 

(defun sendto (flag data side nl)
  (prog nil
   top  (and (not nl) (return nil))
        (setq *side* side)
        (setq *flag-part* flag)
        (setq *data-part* data)
        (setq *sendtocall* t)
	(setq *last-node* (car nl))
        (apply (caar nl) (cdar nl))
        (setq nl (cdr nl))
        (go top))) 

; &bus sets up the registers for the one-input nodes.  note that this
(defun &bus (outs)
  (prog (dp)
        (setq *alpha-flag-part* *flag-part*)
        (setq *alpha-data-part* *data-part*)
        (setq dp (car *data-part*))
        (setq *c1* (car dp))
        (setq dp (cdr dp))
        (setq *c2* (car dp))
        (setq dp (cdr dp))
        (setq *c3* (car dp))
        (setq dp (cdr dp))
        (setq *c4* (car dp))
        (setq dp (cdr dp))
        (setq *c5* (car dp))
        (setq dp (cdr dp))
        (setq *c6* (car dp))
        (setq dp (cdr dp))
        (setq *c7* (car dp))
        (setq dp (cdr dp))
        (setq *c8* (car dp))
        (setq dp (cdr dp))
        (setq *c9* (car dp))
        (setq dp (cdr dp))
        (setq *c10* (car dp))
        (setq dp (cdr dp))
        (setq *c11* (car dp))
        (setq dp (cdr dp))
        (setq *c12* (car dp))
        (setq dp (cdr dp))
        (setq *c13* (car dp))
        (setq dp (cdr dp))
        (setq *c14* (car dp))
        (setq dp (cdr dp))
        (setq *c15* (car dp))
        (setq dp (cdr dp))
        (setq *c16* (car dp))
        (setq dp (cdr dp))
        (setq *c17* (car dp))
        (setq dp (cdr dp))
        (setq *c18* (car dp))
        (setq dp (cdr dp))
        (setq *c19* (car dp))
        (setq dp (cdr dp))
        (setq *c20* (car dp))
        (setq dp (cdr dp))
        (setq *c21* (car dp))
        (setq dp (cdr dp))
        (setq *c22* (car dp))
        (setq dp (cdr dp))
        (setq *c23* (car dp))
        (setq dp (cdr dp))
        (setq *c24* (car dp))
        (setq dp (cdr dp))
        (setq *c25* (car dp))
        (setq dp (cdr dp))
        (setq *c26* (car dp))
        (setq dp (cdr dp))
        (setq *c27* (car dp))
        (setq dp (cdr dp))
        (setq *c28* (car dp))
        (setq dp (cdr dp))
        (setq *c29* (car dp))
        (setq dp (cdr dp))
        (setq *c30* (car dp))
        (setq dp (cdr dp))
        (setq *c31* (car dp))
        (setq dp (cdr dp))
        (setq *c32* (car dp))
        (setq dp (cdr dp))
        (setq *c33* (car dp))
        (setq dp (cdr dp))
        (setq *c34* (car dp))
        (setq dp (cdr dp))
        (setq *c35* (car dp))
        (setq dp (cdr dp))
        (setq *c36* (car dp))
        (setq dp (cdr dp))
        (setq *c37* (car dp))
        (setq dp (cdr dp))
        (setq *c38* (car dp))
        (setq dp (cdr dp))
        (setq *c39* (car dp))
        (setq dp (cdr dp))
        (setq *c40* (car dp))
        (setq dp (cdr dp))
        (setq *c41* (car dp))
        (setq dp (cdr dp))
        (setq *c42* (car dp))
        (setq dp (cdr dp))
        (setq *c43* (car dp))
        (setq dp (cdr dp))
        (setq *c44* (car dp))
        (setq dp (cdr dp))
        (setq *c45* (car dp))
        (setq dp (cdr dp))
        (setq *c46* (car dp))
        (setq dp (cdr dp))
        (setq *c47* (car dp))
        (setq dp (cdr dp))
        (setq *c48* (car dp))
        (setq dp (cdr dp))
        (setq *c49* (car dp))
        (setq dp (cdr dp))
        (setq *c50* (car dp))
        (setq dp (cdr dp))
        (setq *c51* (car dp))
        (setq dp (cdr dp))
        (setq *c52* (car dp))
        (setq dp (cdr dp))
        (setq *c53* (car dp))
        (setq dp (cdr dp))
        (setq *c54* (car dp))
        (setq dp (cdr dp))
        (setq *c55* (car dp))
        (setq dp (cdr dp))
        (setq *c56* (car dp))
        (setq dp (cdr dp))
        (setq *c57* (car dp))
        (setq dp (cdr dp))
        (setq *c58* (car dp))
        (setq dp (cdr dp))
        (setq *c59* (car dp))
        (setq dp (cdr dp))
        (setq *c60* (car dp))
        (setq dp (cdr dp))
        (setq *c61* (car dp))
        (setq dp (cdr dp))
        (setq *c62* (car dp))
        (setq dp (cdr dp))
        (setq *c63* (car dp))
        (setq dp (cdr dp))
        (setq *c64* (car dp))
        (eval-nodelist outs))) 

(defun &any (outs register const-list)
  (prog (z c)
        (setq z (fast-symeval register))
        (cond ((numberp z) (go number)))
   symbol (cond ((null const-list) (return nil))
                ((eq (car const-list) z) (go ok))
                (t (setq const-list (cdr const-list)) (go symbol)))
   number (cond ((null const-list) (return nil))
                ((and (numberp (setq c (car const-list)))
                      (=alg c z))
                 (go ok))
                (t (setq const-list (cdr const-list)) (go number)))
   ok   (eval-nodelist outs))) 

(defun teqa (outs register constant)
  (and (eq (fast-symeval register) constant) (eval-nodelist outs))) 

(defun tnea (outs register constant)
  (and (not (eq (fast-symeval register) constant)) (eval-nodelist outs))) 

(defun txxa (outs register constant)
  (and (symbolp (fast-symeval register)) (eval-nodelist outs))) 

(defun teqn (outs register constant)
  (prog (z)
        (setq z (fast-symeval register))
        (and (numberp z)
             (=alg z constant)
             (eval-nodelist outs)))) 

(defun tnen (outs register constant)
  (prog (z)
        (setq z (fast-symeval register))
        (and (or (not (numberp z))
                 (not (=alg z constant)))
             (eval-nodelist outs)))) 

(defun txxn (outs register constant)
  (prog (z)
        (setq z (fast-symeval register))
        (and (numberp z) (eval-nodelist outs)))) 

(defun tltn (outs register constant)
  (prog (z)
        (setq z (fast-symeval register))
        (and (numberp z)
             (greaterp constant z)
             (eval-nodelist outs)))) 

(defun tgtn (outs register constant)
  (prog (z)
        (setq z (fast-symeval register))
        (and (numberp z)
             (greaterp z constant)
             (eval-nodelist outs)))) 

(defun tgen (outs register constant)
  (prog (z)
        (setq z (fast-symeval register))
        (and (numberp z)
             (not (greaterp constant z))
             (eval-nodelist outs)))) 

(defun tlen (outs register constant)
  (prog (z)
        (setq z (fast-symeval register))
        (and (numberp z)
             (not (greaterp z constant))
             (eval-nodelist outs)))) 

(defun teqs (outs vara varb)
  (prog (a b)
        (setq a (fast-symeval vara))
        (setq b (fast-symeval varb))
        (cond ((eq a b) (eval-nodelist outs))
              ((and (numberp a)
                    (numberp b)
                    (=alg a b))
               (eval-nodelist outs))))) 

(defun tnes (outs vara varb)
  (prog (a b)
        (setq a (fast-symeval vara))
        (setq b (fast-symeval varb))
        (cond ((eq a b) (return nil))
              ((and (numberp a)
                    (numberp b)
                    (=alg a b))
               (return nil))
              (t (eval-nodelist outs))))) 

(defun txxs (outs vara varb)
  (prog (a b)
        (setq a (fast-symeval vara))
        (setq b (fast-symeval varb))
        (cond ((and (numberp a) (numberp b)) (eval-nodelist outs))
              ((and (not (numberp a)) (not (numberp b)))
               (eval-nodelist outs))))) 

(defun tlts (outs vara varb)
  (prog (a b)
        (setq a (fast-symeval vara))
        (setq b (fast-symeval varb))
        (and (numberp a)
             (numberp b)
             (greaterp b a)
             (eval-nodelist outs)))) 

(defun tgts (outs vara varb)
  (prog (a b)
        (setq a (fast-symeval vara))
        (setq b (fast-symeval varb))
        (and (numberp a)
             (numberp b)
             (greaterp a b)
             (eval-nodelist outs)))) 

(defun tges (outs vara varb)
  (prog (a b)
        (setq a (fast-symeval vara))
        (setq b (fast-symeval varb))
        (and (numberp a)
             (numberp b)
             (not (greaterp b a))
             (eval-nodelist outs)))) 

(defun tles (outs vara varb)
  (prog (a b)
        (setq a (fast-symeval vara))
        (setq b (fast-symeval varb))
        (and (numberp a)
             (numberp b)
             (not (greaterp a b))
             (eval-nodelist outs)))) 

(defun &two (left-outs right-outs)
  (prog (fp dp)
        (cond (*sendtocall*
               (setq fp *flag-part*)
               (setq dp *data-part*))
              (t
               (setq fp *alpha-flag-part*)
               (setq dp *alpha-data-part*)))
        (sendto fp dp 'left left-outs)
        (sendto fp dp 'right right-outs))) 

(defun &mem (left-outs right-outs memory-list)
  (prog (fp dp)
        (cond (*sendtocall*
               (setq fp *flag-part*)
               (setq dp *data-part*))
              (t
               (setq fp *alpha-flag-part*)
               (setq dp *alpha-data-part*)))
        (sendto fp dp 'left left-outs)
        (add-token memory-list fp dp nil)
        (sendto fp dp 'right right-outs))) 

(defun &and (outs lpred rpred tests)
  (prog (mem)
        (cond ((eq *side* 'right) (setq mem (memory-part lpred)))
              (t (setq mem (memory-part rpred))))
        (cond ((not mem) (return nil))
              ((eq *side* 'right) (and-right outs mem tests))
              (t (and-left outs mem tests))))) 

(defun and-left (outs mem tests)
  (prog (fp dp memdp tlist tst lind rind res)
        (setq fp *flag-part*)
        (setq dp *data-part*)
   fail (and (null mem) (return nil))
        (setq memdp (car mem))
        (setq mem (cdr mem))
        (setq tlist tests)
   tloop (and (null tlist) (go succ))
        (setq tst (car tlist))
        (setq tlist (cdr tlist))
        (setq lind (car tlist))
        (setq tlist (cdr tlist))
        (setq rind (car tlist))
        (setq tlist (cdr tlist))
        ;the next line differs in and-left & -right
        (setq res (funcall tst (gelm memdp rind) (gelm dp lind)))
        (cond (res (go tloop))
              (t (go fail)))
   succ ;the next line differs in and-left & -right
        (sendto fp (cons (car memdp) dp) 'left outs)
        (go fail))) 

(defun and-right (outs mem tests)
  (prog (fp dp memdp tlist tst lind rind res)
        (setq fp *flag-part*)
        (setq dp *data-part*)
   fail (and (null mem) (return nil))
        (setq memdp (car mem))
        (setq mem (cdr mem))
        (setq tlist tests)
   tloop (and (null tlist) (go succ))
        (setq tst (car tlist))
        (setq tlist (cdr tlist))
        (setq lind (car tlist))
        (setq tlist (cdr tlist))
        (setq rind (car tlist))
        (setq tlist (cdr tlist))
        ;the next line differs in and-left & -right
        (setq res (funcall tst (gelm dp rind) (gelm memdp lind)))
        (cond (res (go tloop))
              (t (go fail)))
   succ ;the next line differs in and-left & -right
        (sendto fp (cons (car dp) memdp) 'right outs)
        (go fail))) 


(defun teqb (new eqvar)
  (cond ((eq new eqvar) t)
        ((not (numberp new)) nil)
        ((not (numberp eqvar)) nil)
        ((=alg new eqvar) t)
        (t nil))) 

(defun tneb (new eqvar)
  (cond ((eq new eqvar) nil)
        ((not (numberp new)) t)
        ((not (numberp eqvar)) t)
        ((=alg new eqvar) nil)
        (t t))) 

(defun tltb (new eqvar)
  (cond ((not (numberp new)) nil)
        ((not (numberp eqvar)) nil)
        ((greaterp eqvar new) t)
        (t nil))) 

(defun tgtb (new eqvar)
  (cond ((not (numberp new)) nil)
        ((not (numberp eqvar)) nil)
        ((greaterp new eqvar) t)
        (t nil))) 

(defun tgeb (new eqvar)
  (cond ((not (numberp new)) nil)
        ((not (numberp eqvar)) nil)
        ((not (greaterp eqvar new)) t)
        (t nil))) 

(defun tleb (new eqvar)
  (cond ((not (numberp new)) nil)
        ((not (numberp eqvar)) nil)
        ((not (greaterp new eqvar)) t)
        (t nil))) 

(defun txxb (new eqvar)
  (cond ((numberp new)
         (cond ((numberp eqvar) t)
               (t nil)))
        (t
         (cond ((numberp eqvar) nil)
               (t t))))) 


(defun &p (rating name var-dope ce-var-dope rhs)
  (prog (fp dp)
        (cond (*sendtocall*
               (setq fp *flag-part*)
               (setq dp *data-part*))
              (t
               (setq fp *alpha-flag-part*)
               (setq dp *alpha-data-part*)))
        (and (member fp '(nil old)) (removecs name dp))
        (and fp (insertcs name dp rating)))) 

(defun &old (a b c d e) nil) ;a null function used for deleting node

(defun &not (outs lmem rpred tests)
  (cond ((and (eq *side* 'right) (eq *flag-part* 'old)) nil)
        ((eq *side* 'right) (not-right outs (car lmem) tests))
        (t (not-left outs (memory-part rpred) tests lmem)))) 

(defun not-left (outs mem tests own-mem)
  (prog (fp dp memdp tlist tst lind rind res c)
        (setq fp *flag-part*)
        (setq dp *data-part*)
        (setq c 0.)
   fail (and (null mem) (go fin))
        (setq memdp (car mem))
        (setq mem (cdr mem))
        (setq tlist tests)
   tloop (and (null tlist) (setq c (1+ c)) (go fail))
        (setq tst (car tlist))
        (setq tlist (cdr tlist))
        (setq lind (car tlist))
        (setq tlist (cdr tlist))
        (setq rind (car tlist))
        (setq tlist (cdr tlist))
        ;the next line differs in not-left & -right
        (setq res (funcall tst (gelm memdp rind) (gelm dp lind)))
        (cond (res (go tloop))
              (t (go fail)))
   fin  (add-token own-mem fp dp c)
        (and (== c 0.) (sendto fp dp 'left outs)))) 

(defun not-right (outs mem tests)
  (prog (fp dp memdp tlist tst lind rind res newfp inc newc)
        (setq fp *flag-part*)
        (setq dp *data-part*)
        (cond ((not fp) (setq inc -1.) (setq newfp 'new))
              ((eq fp 'new) (setq inc 1.) (setq newfp nil))
              (t (return nil)))
   fail (and (null mem) (return nil))
        (setq memdp (car mem))
        (setq newc (cadr mem))
        (setq tlist tests)
   tloop (and (null tlist) (go succ))
        (setq tst (car tlist))
        (setq tlist (cdr tlist))
        (setq lind (car tlist))
        (setq tlist (cdr tlist))
        (setq rind (car tlist))
        (setq tlist (cdr tlist))
        ;the next line differs in not-left & -right
        (setq res (funcall tst (gelm dp rind) (gelm memdp lind)))
        (cond (res (go tloop))
              (t (setq mem (cddr mem)) (go fail)))
   succ (setq newc (+ inc newc))
        (rplaca (cdr mem) newc)
        (cond ((or (and (== inc -1.) (== newc 0.))
                   (and (== inc 1.) (== newc 1.)))
               (sendto newfp memdp 'right outs)))
        (setq mem (cddr mem))
        (go fail))) 



;;; Node memories


(defun add-token (memlis flag data-part num)
  (prog (was-present)
        (cond ((eq flag 'new)
               (setq was-present nil)
               (real-add-token memlis data-part num))
              ((not flag) 
	       (setq was-present (remove-old memlis data-part num)))
              ((eq flag 'old) (setq was-present t)))
        (return was-present))) 

(defun real-add-token (lis data-part num)
  (setq *current-token* (1+ *current-token*))
  (cond (num (rplaca lis (cons num (car lis)))))
  (rplaca lis (cons data-part (car lis)))) 

(defun remove-old (lis data num)
  (cond (num (remove-old-num lis data))
        (t (remove-old-no-num lis data)))) 

(defun remove-old-num (lis data)
  (prog (m next last)
        (setq m (car lis))
        (cond ((atom m) (return nil))
              ((top-levels-eq data (car m))
               (setq *current-token* (1- *current-token*))
               (rplaca lis (cddr m))
               (return (car m))))
        (setq next m)
   loop (setq last next)
        (setq next (cddr next))
        (cond ((atom next) (return nil))
              ((top-levels-eq data (car next))
               (rplacd (cdr last) (cddr next))
               (setq *current-token* (1- *current-token*))
               (return (car next)))
              (t (go loop))))) 

(defun remove-old-no-num (lis data)
  (prog (m next last)
        (setq m (car lis))
        (cond ((atom m) (return nil))
              ((top-levels-eq data (car m))
               (setq *current-token* (1- *current-token*))
               (rplaca lis (cdr m))
               (return (car m))))
        (setq next m)
   loop (setq last next)
        (setq next (cdr next))
        (cond ((atom next) (return nil))
              ((top-levels-eq data (car next))
               (rplacd last (cdr next))
               (setq *current-token* (1- *current-token*))
               (return (car next)))
              (t (go loop))))) 



;;; Conflict Resolution
;
;
; each conflict set element is a list of the following form:
; ((p-name . data-part) (sorted wm-recency) special-case-number)

(defun removecs (name data)
  (prog (cr-data inst cs)
        (setq cr-data (cons name data))
	(setq cs *conflict-set*)
 loop1	(cond ((null cs) 
               (record-refract name data)
               (return nil)))
	(setq inst (car cs))
	(setq cs (cdr cs))
	(and (not (top-levels-eq (car inst) cr-data)) (go loop1))
        (setq *conflict-set* (delete inst *conflict-set* :test #'eq))))

(defun insertcs (name data rating)
  (prog (instan)
    (and (refracted name data) (return nil))
    (setq instan (list (cons name data) (order-tags data) rating))
    (and (atom *conflict-set*) (setq *conflict-set* nil))
    (return (setq *conflict-set* (cons instan *conflict-set*))))) 

(defun order-tags (dat)
  (prog (tags)
        (setq tags nil)
   l1  (and (atom dat) (go l2))
        (setq tags (cons (creation-time (car dat)) tags))
        (setq dat (cdr dat))
        (go l1)
   l2  (cond ((eq *strategy* 'mea)
               (return (cons (car tags) (dsort (cdr tags)))))
              (t (return (dsort tags)))))) 

; destructively sort x into descending order

(defun dsort (x)
  (prog (sorted cur next cval nval)
        (and (atom (cdr x)) (return x))
   loop (setq sorted t)
        (setq cur x)
        (setq next (cdr x))
   chek (setq cval (car cur))
        (setq nval (car next))
        (cond ((> nval cval)
               (setq sorted nil)
               (rplaca cur nval)
               (rplaca next cval)))
        (setq cur next)
        (setq next (cdr cur))
        (cond ((not (null next)) (go chek))
              (sorted (return x))
              (t (go loop))))) 

(defun conflict-resolution nil
  (prog (best len)
        (setq len (length *conflict-set*))
        (cond ((> len *max-cs*) (setq *max-cs* len)))
        (setq *total-cs* (+ *total-cs* len))
        (cond (*conflict-set*
               (setq best (best-of *conflict-set*))
               (setq *conflict-set* (delete best *conflict-set* :test #'eq))
               (return (pname-instantiation best)))
              (t (return nil))))) 

(defun best-of (set) (best-of* (car set) (cdr set))) 

(defun best-of* (best rem)
  (cond ((not rem) best)
        ((conflict-set-compare best (car rem))
         (best-of* best (cdr rem)))
        (t (best-of* (car rem) (cdr rem))))) 

(defun remove-from-conflict-set (name)
  (prog (cs entry)
   l1   (setq cs *conflict-set*)
   l2   (cond ((atom cs) (return nil)))
        (setq entry (car cs))
        (setq cs (cdr cs))
        (cond ((eq name (caar entry))
               (setq *conflict-set* (delete entry *conflict-set* :test #'eq))
               (go l1))
              (t (go l2))))) 

(defun pname-instantiation (conflict-elem) (car conflict-elem)) 

(defun order-part (conflict-elem) (cdr conflict-elem)) 

(defun instantiation (conflict-elem)
  (cdr (pname-instantiation conflict-elem))) 


(defun conflict-set-compare (x y)
  (prog (x-order y-order xl yl xv yv)
        (setq x-order (order-part x))
        (setq y-order (order-part y))
        (setq xl (car x-order))
        (setq yl (car y-order))
   data (cond ((and (null xl) (null yl)) (go ps))
              ((null yl) (return t))
              ((null xl) (return nil)))
        (setq xv (car xl))
        (setq yv (car yl))
        (cond ((> xv yv) (return t))
              ((> yv xv) (return nil)))
        (setq xl (cdr xl))
        (setq yl (cdr yl))
        (go data)
   ps   (setq xl (cdr x-order))
        (setq yl (cdr y-order))
   psl  (cond ((null xl) (return t)))
        (setq xv (car xl))
        (setq yv (car yl))
        (cond ((> xv yv) (return t))
              ((> yv xv) (return nil)))
        (setq xl (cdr xl))
        (setq yl (cdr yl))
        (go psl))) 


(defun conflict-set nil
  (prog (cnts cs p z best)
        (setq cnts nil)
        (setq cs *conflict-set*)
   l1  (and (atom cs) (go l2))
        (setq p (caaar cs))
        (setq cs (cdr cs))
        (setq z (assoc p cnts :test #'eq))
        (cond ((null z) (setq cnts (cons (cons p 1.) cnts)))
              (t (rplacd z (1+ (cdr z)))))
        (go l1)
   l2  (cond ((atom cnts)
               (setq best (best-of *conflict-set*))
               (terpri)
               (return (list (caar best) 'dominates))))
        (terpri)
        (princ (caar cnts))
        (cond ((> (cdar cnts) 1.)
               (princ '|	(|)
               (princ (cdar cnts))
               (princ '| occurrences)|)))
        (setq cnts (cdr cnts))
        (go l2))) 


